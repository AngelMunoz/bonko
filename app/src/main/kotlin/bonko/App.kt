/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package bonko

import io.ktor.client.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.client.statement.*
import io.ktor.util.*
import java.io.ByteArrayInputStream
import java.io.File
import java.io.FileOutputStream
import java.util.zip.*
import kotlinx.coroutines.*

const val RELEASES_URL_TPL = "https://github.com/oven-sh/bun/releases/download"

public sealed class Platform {
    object Windows : Platform()
    object MacOS : Platform()
    object Linux : Platform()

    object Unknown : Platform()

    companion object Helpers {
        public val current
            get(): Platform {
                val osName = System.getProperty("os.name").toLowerCase()
                val isWindows = osName.contains("win")
                val isMac = osName.contains("mac")
                val isLinux = osName.contains("nux") || osName.contains("nix")
                if (isWindows) return Windows
                if (isMac) return MacOS
                if (isLinux) return Linux
                return Unknown
            }
    }

    fun asString(): String {
        return when (this) {
            is Windows -> "windows"
            is Linux -> "linux"
            is MacOS -> "darwin"
            is Unknown -> "unknown"
        }
    }

}

fun unzip(zip: ZipInputStream): String {
    var firstPath: String? = null
    var entry = zip.nextEntry

    while (entry != null) {
        val filePath = "./downloaded/${entry.name}"
        val file = File(filePath)

        if (firstPath == null) {
            firstPath = file.absolutePath
        }

        if (entry.isDirectory) {
            file.mkdirs()
        } else {
            val parentDirs = file.parentFile
            if (parentDirs != null && !parentDirs.isDirectory) file.mkdirs()
            FileOutputStream(filePath).use {
                zip.copyTo(it)
            }
        }
        entry = zip.nextEntry
    }

    if (firstPath != null) {
        val path = "$firstPath/bun"
        try {
            var file = File(path)
            file.setExecutable(true)
        } catch (err: Exception) {
            println("We couldn't make '$path' Executable...")
        }
    }

    return firstPath.orEmpty()
}

suspend fun downloadBun(tag: String, os: String, arch: String, isBaseline: Boolean = false): ByteArray {
    val client = HttpClient(CIO)
    val baseline = if (isBaseline) "-baseline" else ""
    val target = "/$tag/bun-$os-$arch$baseline.zip"
    val response: HttpResponse = client.get("$RELEASES_URL_TPL$target")
    val channel = response.bodyAsChannel().toByteArray()
    client.close()
    return channel
}

class Bun(private val pathToBun: String) {
    private val args = mutableListOf<String>()

    private fun add(arg: String): Bun {
        args.add(arg)
        return this
    }

    fun addVersion(): Bun {
        this.add("--version")
        return this
    }

    fun build(): Process {
        return ProcessBuilder(pathToBun, *args.toTypedArray())
                .redirectError(ProcessBuilder.Redirect.INHERIT)
                .redirectInput(ProcessBuilder.Redirect.INHERIT)
                .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                .start()
    }
}

suspend fun setupBun(targetPath: String, version: String): String {
    val tag = "bun-v$version"
    val os = Platform.current.asString()
    val arch: String = "x64"
    val isBaseline: Boolean = false
    val baseline = if (isBaseline) "-baseline" else ""
    val targetName = "bun-$os-$arch$baseline"
    val file = File("$targetPath/$targetName/bun")

    if (!file.exists()) {
        val zipContent = downloadBun(tag, os, arch, isBaseline)
        val zip = ZipInputStream(ByteArrayInputStream(zipContent))
        return unzip(zip)
    } else {
        return file.absolutePath
    }
}

suspend fun main() {
    println("Setting up Bun...")
    val path = setupBun("./downloaded/bun-darwin-x64", "0.5.9")
    println("Downloaded to $path")
    val cmd = Bun("$path/bun").addVersion().build()
    cmd.waitFor()
}
